// Generated by CoffeeScript 1.6.3
(function() {
  var QUnit, async, dockers, fs, q;

  fs = require('fs');

  async = require('async');

  if (typeof QUnit === "undefined" || QUnit === null) {
    QUnit = require('qunit-cli');
  }

  q = QUnit;

  q.module('dockers');

  dockers = require('../index');

  q.test('pipeline', function() {
    var text1, text2;
    text1 = "* Metadata: `[[metadata]]`\n* Categories: `[[#category]]`\n* Replacements: `{{replacement}}`\n	* Transclusion: `{{>page}}`\n	* Templates: `{{template|option1|option2|named_option=value}}`\n	* Alternatively:";
    q.stop();
    dockers.pipeline(text1, {
      from: 'markdown',
      to: 'html'
    }, [
      function(tree, cb) {
        q.ok(tree, 'A tree is passed to the first middleware');
        return cb(null, tree);
      }
    ], function(err, html) {
      q.ok(err == null, 'No error is raised in the pipeline');
      if (err) {
        console.log(err);
      }
      q.ok(html != null, 'Some HTML is returned');
      return q.start();
    });
    text2 = "[Test wikilink]()";
    q.stop();
    return dockers.pipeline(text2, {
      from: 'markdown',
      to: 'html'
    }, [
      function(tree, cb) {
        tree[1][0].Para[0].Link[1][0] = "/pages/Test%20wikilink.md/view";
        return cb(null, tree);
      }
    ], function(err, html) {
      q.ok(err == null, 'No error is raised in the pipeline');
      if (err) {
        console.log(err);
      }
      q.ok(html != null, 'Some HTML is returned');
      q.equal(html, '<p><a href="/pages/Test%20wikilink.md/view">Test wikilink</a></p>\n', 'Returned HTML is correct');
      return q.start();
    });
  });

  q.test('convert', function() {
    var text1, text2;
    text1 = "**Hello world!**";
    text2 = "<b>Hello world! Hello world! Hello world! Hello world! Hello world! Hello world! Hello world! Hello world!</b>";
    q.stop();
    return async.series([
      function(cb) {
        return dockers.convert(text1, {}, function(err, html) {
          q.ok(err == null, 'No error is raised in conversion');
          q.ok(html != null, 'Some HTML is returned');
          q.equal(html, '<p><strong>Hello world!</strong></p>\n', 'Returned HTML is correct');
          return cb(null);
        });
      }, function(cb) {
        return dockers.convert(text1, {
          '--self-contained': true
        }, function(err, html) {
          q.ok(err == null, 'No error is raised in conversion');
          q.ok(html != null, 'Some HTML is returned');
          q.equal(html, "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <meta http-equiv=\"Content-Style-Type\" content=\"text/css\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <title></title>\n  <style type=\"text/css\">code{white-space: pre;}</style>\n</head>\n<body>\n<p><strong>Hello world!</strong></p>\n</body>\n</html>\n", 'Returned HTML is correct');
          return cb(null);
        });
      }, function(cb) {
        return dockers.convert(text2, {
          from: 'html',
          to: 'markdown',
          '--columns': 10
        }, function(err, md) {
          q.ok(err == null, 'No error is raised in conversion');
          q.ok(md != null, 'Some markdown is returned');
          q.equal(md, "**Hello\nworld!\nHello\nworld!\nHello\nworld!\nHello\nworld!\nHello\nworld!\nHello\nworld!\nHello\nworld!\nHello\nworld!**\n", 'Returned markdown is correct');
          return cb(null);
        });
      }
    ], function(err) {
      return q.start();
    });
  });

  q.test('convertFile', function() {
    var text1;
    text1 = "* Metadata: `[[metadata]]`\n* Categories: `[[#category]]`\n* Replacements: `{{replacement}}`\n	* Transclusion: `{{>page}}`\n	* Templates: `{{template|option1|option2|named_option=value}}`\n	* Alternatively:";
    q.stop();
    return dockers.convertFile(text1, {
      from: 'markdown',
      to: 'docx'
    }, function(err, filename) {
      q.ok(err == null, 'No error on conversion');
      if (err) {
        console.log(err);
      }
      q.ok(filename != null, 'Temporary filename generated');
      q.ok(fs.existsSync(filename), 'File at filename exists');
      return q.start();
    });
  });

}).call(this);
