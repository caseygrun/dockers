// Generated by CoffeeScript 1.6.3
(function() {
  var async, buildArguments, defaultOptions, formats, getFormatOptions, me, pandoc, pdc, pdcToFile, pipeline, pth, runPandoc, spawn, tempFile, tmp, _;

  _ = require('underscore');

  async = require('async');

  tmp = require('tmp');

  pth = require('path');

  spawn = require('child_process').spawn;

  formats = {
    'pdf': [null, []]
  };

  defaultOptions = {
    'from': 'markdown',
    'to': 'html'
  };

  getFormatOptions = function(to, opt) {
    if (formats[to]) {
      opt.concat(formats[to][1]);
      to = formats[to][0];
    }
    return [to, opt];
  };

  buildArguments = function(opt) {
    var args, key, value;
    args = [];
    for (key in opt) {
      value = opt[key];
      if (key === 'to') {
        key = '-t';
      }
      if (key === 'from') {
        key = '-f';
      }
      if (key === 'out') {
        key = '-o';
      }
      if (value && value !== true) {
        args.push(key);
        args.push(value);
      } else {
        args.push(key);
      }
    }
    return args;
  };

  /**
   * Invokes Pandoc with the given source text and array of command-line options
   * @param  {String} src Input text
   * @param  {String[]} args Command line options
   * @param  {Function} callback Callback to be executed upon completion
   * @param  {Error} callback.err Error if one occurs
   * @param  {String} callback.result Output text
  */


  runPandoc = function(src, args, callback) {
    return (function(src, args, callback) {
      var err, pandoc, res;
      pandoc = spawn('pandoc', args);
      res = '';
      err = '';
      pandoc.stdout.setEncoding('utf8');
      pandoc.stderr.setEncoding('utf8');
      pandoc.stdout.on('data', function(data) {
        res += data;
        return null;
      });
      pandoc.stderr.on('data', function(data) {
        err += data;
        return null;
      });
      pandoc.on('close', function(code) {
        if (code !== 0) {
          return callback(new Error('pandoc exited with code ' + code + '. ' + (err || '')));
        } else if (err) {
          return callback(new Error(err));
        } else {
          callback(null, res);
          return null;
        }
      });
      pandoc.stdout.resume();
      pandoc.stderr.resume();
      return pandoc.stdin.end(src, 'utf8');
    })(src, args, callback);
  };

  pandoc = function(src, opt, cb) {
    var args;
    args = buildArguments(opt);
    return runPandoc(src, args, cb);
  };

  /**
   * Invokes pandoc to convert the input text `src` from one format to another, with optional arguments `opt`
   * @param  {String} src Input text
   * @param  {String} from Input format (e.g. `markdown`, `html`, etc. )
   * @param  {String} to Output format (e.g. `markdown`, `html`, `latex`, etc.)
   * @param  {String[]} opt Array of command line options to be passed to Pandoc
   * @param  {Function} callback Callback to be executed upon completion
   * @param  {Error} callback.err Error if one occurs
   * @param  {String} callback.result Output text
  */


  pdc = function(src, from, to, opt, cb) {
    var args, _ref;
    if (cb == null) {
      cb = opt;
      opt = null;
    }
    args = ['-f', from];
    _ref = getFormatOptions(to, opt), to = _ref[0], opt = _ref[1];
    if (to != null) {
      args = args.concat(['-t', to]);
    }
    if (opt != null) {
      args = args.concat(opt);
    }
    return runPandoc(src, args, cb);
  };

  pdcToFile = function(src, from, to, out, opt, cb) {
    var args, _ref;
    if (cb == null) {
      cb = opt;
      opt = null;
    }
    args = ['-f', from];
    _ref = getFormatOptions(to, opt), to = _ref[0], opt = _ref[1];
    if (to != null) {
      args = args.concat(['-t', to]);
    }
    if (out != null) {
      args = args.concat(['-o', out]);
    }
    if (opt != null) {
      args = args.concat(opt);
    }
    return runPandoc(src, args, cb);
  };

  /**
   * Runs a pipeline of middleware to process JSON trees from Pandoc
   * @param  {String} text Input text
   * @param  {Object} options Hash of options to be passed to Pandoc
   * 
   * @param  {Function[]} middleware 
   * Array of functions to be called between the input and output.
   * Each function will be passed two arguments:
   * 
   *     - `currentTree`: a JSON array containing the current Pandoc document tree, 
   *        as modified by previous middleware
   *     - `next(err, updatedTree)`: a callback to be called upon completion of the present middleware
   * 
   * Each middleware function should modify the passed `currentTree` as suitable, then call `next` 
   * with either an `Error` or the modified tree. This modified tree will be passed to subsequent 
   * middleware, and so forth.
   *
   * @param  {Function} callback Callback to be executed upon completion
   * @param {Error} callback.err Error if one occurs
   * @param {String} callback.output Output text
  */


  pipeline = function(text, options, middleware, callback) {
    var chain, from, post, pre, to;
    if (options == null) {
      options = {};
    }
    _.defaults(options, defaultOptions);
    from = options.from;
    to = options.to;
    delete options.from;
    delete options.to;
    pre = function(cb) {
      return pandoc(text, {
        from: from,
        to: 'json'
      }, function(err, tree) {
        var e, t;
        if (err) {
          return cb(err);
        } else {
          try {
            t = JSON.parse(tree);
          } catch (_error) {
            e = _error;
            return cb(e);
          }
          return cb(null, t);
        }
      });
    };
    post = function(tree, cb) {
      var finalText;
      finalText = JSON.stringify(tree);
      return pandoc(finalText, _.extend({
        from: 'json',
        to: to
      }, options), cb);
    };
    chain = [pre].concat(middleware).concat([post]);
    return async.waterfall(chain, callback);
  };

  /**
   * Generates a path to a temporary file, optionally touching that file
   * @param  {Mixed} data If not null, the file will be created on disk. Otherwise, only a file path will be returned
   * @param  {Function} cb Callback to be passed the new filename
   * @param {Error} cb.err Error if one occurs while creating the new file
   * @param {String} cb.filename Path to the new file
  */


  tempFile = function(data, cb) {
    if (cb == null) {
      cb = data;
      data = null;
    }
    if (data) {
      return tmp.file(cb);
    } else {
      return tmp.tmpName(cb);
    }
  };

  module.exports = me = {
    pipeline: function(text, options, middleware, callback) {
      return pipeline(text, options, middleware, callback);
    },
    pipelineFile: function(text, from, to, options, middleware, callback) {},
    convert: function(text, options, callback) {
      if (options == null) {
        options = {};
      }
      return pandoc(text, options, callback);
    },
    convertFile: function(text, options, callback) {
      return tempFile(function(err, outputFile) {
        if (err) {
          return callback(err);
        }
        return pandoc(text, _.extend({
          'out': outputFile
        }, options), function(err, data) {
          return callback(err, outputFile);
        });
      });
    }
  };

}).call(this);
