// Generated by CoffeeScript 1.6.3
(function() {
  var BlockQuote, BulletList, Cite, Code, CodeBlock, DefinitionList, Div, Emph, Header, HorizontalRule, Image, LineBreak, Link, Math, Note, Null, OrderedList, Para, Plain, Quoted, RawBlock, RawInline, SmallCaps, Space, Span, Str, Strikeout, Strong, Subscript, Superscript, Table, attributes, elements, elt, extractMetadata, extractSection, stringify, toJSONFilter, toJSONPipe, walk, _,
    __slice = [].slice;

  _ = require('underscore');

  /*
  # Functions to aid writing python scripts that process the pandoc
  # AST serialized as JSON.
  */


  /**
   * Walk a tree, applying an action to every object.
   * Returns a modified tree.
  */


  walk = function(x, action, format, meta) {
    var array, item, k, obj, res, v, z, _i, _j, _len, _len1;
    if (_.isArray(x)) {
      array = [];
      for (_i = 0, _len = x.length; _i < _len; _i++) {
        item = x[_i];
        if (_.isObject(item) && ('t' in item)) {
          res = action(item['t'], item['c'], format, meta);
          if (res === null || res === void 0) {
            array.push(walk(item, action, format, meta));
          } else if (_.isArray(res)) {
            for (_j = 0, _len1 = res.length; _j < _len1; _j++) {
              z = res[_j];
              array.push(walk(z, action, format, meta));
            }
          } else {
            array.push(walk(res, action, format, meta));
          }
        } else {
          array.push(walk(item, action, format, meta));
        }
      }
      return array;
    } else if (_.isObject(x)) {
      obj = {};
      for (k in x) {
        v = x[k];
        obj[k] = walk(x[k], action, format, meta);
      }
      return obj;
    } else {
      return x;
    }
  };

  toJSONFilter = function(action) {
    /*
    	Converts an action into a filter that reads a JSON-formatted
    	pandoc document from stdin, transforms it by walking the tree
    	with the action, and returns a new JSON-formatted pandoc document
    	to stdout.  The argument is a function action(key, value, format, meta),
    	where key is the type of the pandoc object (e.g. 'Str', 'Para'),
    	value is the contents of the object (e.g. a string for 'Str',
    	a list of inline elements for 'Para'), format is the target
    	output format (which will be taken for the first command line
    	argument if present), and meta is the document's metadata.
    	If the function returns None, the object to which it applies
    	will remain unchanged.  If it returns an object, the object will
    	be replaced.  If it returns a list, the list will be spliced in to
    	the list to which the target object belongs.  (So, returning an
    	empty list deletes the object.)
    */

    var stdin;
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    stdin = '';
    process.stdin.on('data', function(data) {
      return stdin += data;
    });
    return process.stdin.on('end', function() {
      var altered, doc, format;
      doc = JSON.parse(stdin);
      if (process.argv.length > 1) {
        format = process.argv[1];
      } else {
        format = "";
      }
      altered = walk(doc, action, format, doc[0]['unMeta']);
      return process.stdout.write(JSON.stringify(altered));
    });
  };

  toJSONPipe = function(action, format) {
    return function(doc, cb) {
      var x;
      x = walk(doc, action, format, doc[0]['unMeta']);
      return cb(null, x);
    };
  };

  stringify = function(x) {
    /*
    	Walks the tree x and returns concatenated string content,
    	leaving out all formatting.
    */

    var go, result;
    result = [];
    go = function(key, val, format, meta) {
      if (key === 'Str') {
        return result.push(val);
      } else if (key === 'Code') {
        return result.push(val[1]);
      } else if (key === 'Math') {
        return result.push(val[1]);
      } else if (key === 'LineBreak') {
        return result.push(" ");
      } else if (key === 'Space') {
        return result.push(" ");
      }
    };
    walk(x, go, "", {});
    return result.join('');
  };

  attributes = function(attrs) {
    /*
    	Returns an attribute list, constructed from the
    	dictionary attrs.
    */

    var classes, ident, keyvals, x;
    attrs = attrs || {};
    ident = attrs["id"] || "";
    classes = attrs["classes"] || [];
    keyvals = [
      (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = attrs.length; _i < _len; _i++) {
          x = attrs[_i];
          if (x !== "classes" && x !== "id") {
            _results.push([x, attrs[x]]);
          }
        }
        return _results;
      })()
    ];
    return [ident, classes, keyvals];
  };

  elt = function(eltType, numargs) {
    var fun;
    fun = function() {
      var args, lenargs, xs;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      lenargs = args.length;
      if (lenargs !== numargs) {
        throw eltType + ' expects ' + numargs + ' arguments, but given ' + lenargs;
      }
      if (args.length === 1) {
        xs = args[0];
      } else {
        xs = args;
      }
      return {
        't': eltType,
        'c': xs
      };
    };
    return fun;
  };

  elements = {};

  Plain = elements.Plain = elt('Plain', 1);

  Para = elements.Para = elt('Para', 1);

  CodeBlock = elements.CodeBlock = elt('CodeBlock', 2);

  RawBlock = elements.RawBlock = elt('RawBlock', 2);

  BlockQuote = elements.BlockQuote = elt('BlockQuote', 1);

  OrderedList = elements.OrderedList = elt('OrderedList', 2);

  BulletList = elements.BulletList = elt('BulletList', 1);

  DefinitionList = elements.DefinitionList = elt('DefinitionList', 1);

  Header = elements.Header = elt('Header', 3);

  HorizontalRule = elements.HorizontalRule = elt('HorizontalRule', 0);

  Table = elements.Table = elt('Table', 5);

  Div = elements.Div = elt('Div', 2);

  Null = elements.Null = elt('Null', 0);

  Str = elements.Str = elt('Str', 1);

  Emph = elements.Emph = elt('Emph', 1);

  Strong = elements.Strong = elt('Strong', 1);

  Strikeout = elements.Strikeout = elt('Strikeout', 1);

  Superscript = elements.Superscript = elt('Superscript', 1);

  Subscript = elements.Subscript = elt('Subscript', 1);

  SmallCaps = elements.SmallCaps = elt('SmallCaps', 1);

  Quoted = elements.Quoted = elt('Quoted', 2);

  Cite = elements.Cite = elt('Cite', 2);

  Code = elements.Code = elt('Code', 2);

  Space = elements.Space = elt('Space', 0);

  LineBreak = elements.LineBreak = elt('LineBreak', 0);

  Math = elements.Math = elt('Math', 2);

  RawInline = elements.RawInline = elt('RawInline', 2);

  Link = elements.Link = elt('Link', 2);

  Image = elements.Image = elt('Image', 2);

  Note = elements.Note = elt('Note', 1);

  Span = elements.Span = elt('Span', 2);

  extractMetadata = function(doc) {
    return doc[0]["unMeta"];
  };

  extractSection = function(identifier, format) {
    if (format == null) {
      format = 'html';
    }
    return function(doc, cb) {
      var action, inSection, sectionLevel;
      inSection = false;
      sectionLevel = null;
      action = function(key, value, format, meta) {
        var attrs, classes, data, id, level, text, _ref;
        if (!inSection) {
          if (key === 'Header') {
            level = value[0], (_ref = value[1], id = _ref[0], classes = _ref[1], attrs = _ref[2]), text = value[2];
            if (id === identifier) {
              inSection = true;
              sectionLevel = level;
              return null;
            }
          }
          return [];
        } else if (inSection) {
          if (key === 'Header') {
            level = value[0], data = value[1], text = value[2];
            if (level === sectionLevel) {
              inSection = false;
              return [];
            }
          }
          return null;
        }
      };
      return cb(null, walk(doc, action, format, doc[0]['unMeta']));
    };
  };

  module.exports = {
    walk: walk,
    toJSONFilter: toJSONFilter,
    toJSONPipe: toJSONPipe,
    stringify: stringify,
    attributes: attributes,
    extractSection: extractSection,
    extractMetadata: extractMetadata,
    elements: elements
  };

}).call(this);
